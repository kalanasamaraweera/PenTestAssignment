# PenTestAssignment
SLIIT Penetration Testing Assignment 2020 (3rd Semester)

by S.A.K.G. Samaraweera  (MS19804552)

## SYNOPSIS
This Git branch describes the SQL Injection attacks, could be exploited on Django framework. In order to setup environment please refer ReadMe.md of master branch.


## Pre-Requesits
Before we begin, we need to backup our database. So we can restore it later on, once completed this tutorial as you can use same database for the next tutorial.

### Backup Database
1. Switch to postgres user.
```
$ sudo -i -u postgres
```

2. Create backup file
```
$ pg_dump -u postgres hackmeifucan > before.bak
```

We can use below steps to restore our database once we completed this scenario.

### Restore database

```
$ sudo -i -u postgres
$ psql
> DROP DATABASE "hackmeifucan";
> CREATE DATABASE "hackmeifucan";
> GRANT ALL PRIVILEGES ON DATABASE hackmeifucan TO hackmeadmin;
> \q
$ psql
$ psql hackmeifucan < before.bak
```

## Exploit SQL Injection

Following Django vulnerability allows SQLInjection attacks using `django.contrib.postgres.fields.HStoreField` filed. `HStoreField` allows to store Dictory objects in Postgresql database.

First, we'll create "hstore" extention in the Postgresql database.

Access the database and execute below commands
```
$ sudo -i -u postgres
$ psql
> \c "hackmeifucan";
> CREATE EXRENSION hstore;
```

Once we've added extension, next we can try to migrate our vulnerable column.
Update your models.py file as below.

``` python
from django.db import models
from django.contrib.postgres.fields import HStoreField

class Student(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    grade = models.CharField(max_length=100)
    # 'hstore' column
    marks = HStoreField(null=True, blank=True)
```
Now we can create our next migrations file.
```
$ python manage.py makemigrations

Migrations for 'StudentGradesApp':
  StudentGradesApp/migrations/0002_student_marks.py
    - Add field marks to student
```
In order to migrate, we have to add `HStoreExtension()` to the migration file.
``` python
from django.contrib.postgres.fields import HStoreField
# import HStoreExtension
from django.contrib.postgres.operations import HStoreExtension
from django.db import migrations

class Migration(migrations.Migration):

    dependencies = [
        ('StudentGradesApp', '0001_initial'),
    ]

    operations = [
        # add HStoteExtension()
        HStoreExtension(),

        migrations.AddField(
            model_name='student',
            name='marks',
            field=HStoreField(blank=True, null=True),
        ),
    ]
```
We can now do the database migration. Execute below command to migrate.
```
$ python manage.py migrate
```

### Search for Vulnerabilities

First, we'll create new Student entity in database using Django shell prompt. We can do the same thing using Django admin panel or implementing a Django view. But for sake of clarity we'll proceed this method. Eitherway we have to create new instance of Student model and persist in database.

```
$ python manage.py shell
>>>
```
Now. we'll create an the Student entity.

```
...
>>> from StudentGradesApp.models import Student
>>> Student.objects.create(first_name="John", last_name="Doe",grade="95",marks= {'maths':"88",'science':"75"})
<Student: Student object (2)>
>>>

```
Then, we'll try to query the created Student entity from database. Django calls `Queryset.filter()` method for this.
```
>>> Student.objects.filter(marks_contains='maths')
```
In above query, I intentionaly made a mistake. Closely look in our query stack trace. You'll notice some SQL syntax are directly embeded in to our model fields.

```
The above exception was the direct cause of the following exception:

Traceback (most recent call last):
...

django.db.utils.InternalError: Unexpected end of string
LINE 1: ...dent" WHERE "StudentGradesApp_student"."marks" @> 'maths'  L...
```

Now we'll look into some vulnerable Django queries;

When we type below crafted query, it gives us following result:
```
>>> Student.objects.filter(marks__contains="maths'")
```
Note here, I've crafted an addtional `'` notation to above query. 
```
...

django.db.utils.InternalError: Unexpected end of string
LINE 1: ...dent" WHERE "StudentGradesApp_student"."marks" @> 'maths'''  L...
```

But in resullt it prints as `''`. This means, Django is using purification where it converts whatever the injected syntax to string. Hence we can  conclude Django ORM queries are harden enough against injection attacks.

Now we'll look into other aspects. Django also support execution of RAW SQL queries. In order to demonstrate, I've added below endpoint methods to my `views.py`.

``` python
def get_user(request,name):
    result = Student.objects.raw('SELECT * FROM "StudentGradesApp_student" WHERE first_name=\'%s\';'%name)
    return HttpResponse(result)

def query_user(request):
    name = request.GET.get('name','')
    result = Student.objects.raw('SELECT * FROM "StudentGradesApp_student" WHERE first_name=\'%s\';'%name)
    return HttpResponse(result)
```

These methods uses raw SQL queries to read database tables. 

The first method reads the parameter as part of url pattern

```python
    url(r'username/(?P<name>\w{0,50})/$', views.get_user, name='get_user'),

    # Example:
    # http://url.app/username/George
```
The second method accepts http url query argument

 ```python 
    url(r'username/', views.query_user, name='query_user'),

    # Example:
    # http://url.app/username/?name=George
 ```


 Now we'll perform simple injections for above methods. For this I'll use above created user: `{first_name="John", last_name="Doe",grade="95",marks= {'maths':"88",'science':"75"}}`

 First we'll send GET request for unforged values

 ```
 http://192.168.1.5:8000/students/username/John/

# Output:
Student objectStudent object


 http://192.168.1.5:8000/students/username/?name=John
```
```
 # Output:
 Student objectStudent object
 ```

 This means our functions work as expected. Next we'll perform execute injected requests:

 ```
 http://192.168.1.5:8000/students/username/John'/

# Output:
Empty-Response
```
```

http://192.168.1.5:8000/students/username/?name=John'

# Output:
The above exception (unterminated quoted string at or near "'John'';" LINE 1: ... * FROM "StudentGradesApp_student" WHERE first_name='John''; ^ ) was the direct cause of the following exception: 
 ```
If we carefully go through the second output, it shows the injected `'` parameter has taken as input to the SQL query it self. Therefore it demonstrates usage of `request.GET.get('name','')` method is insecure along with Raw SQL query execution.
As counter measure it could recommed to utlize additional purification for this method.

